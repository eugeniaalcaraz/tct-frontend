import {
  require_react_dom
} from "./chunk-7AIEHXC3.js";
import {
  require_prop_types
} from "./chunk-5YRTH3KM.js";
import {
  require_react
} from "./chunk-YVDZNGKE.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-IKJM6GHQ.js";

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/react-grid-layout/node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; )
    (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/react-grid-layout/node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/react-grid-layout/build/fastRGLPropsEqual.js
var require_fastRGLPropsEqual = __commonJS({
  "node_modules/react-grid-layout/build/fastRGLPropsEqual.js"(exports, module) {
    module.exports = function fastRGLPropsEqual(a, b, isEqualImpl) {
      if (a === b)
        return true;
      return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);
    };
  }
});

// node_modules/react-grid-layout/build/utils.js
var require_utils = __commonJS({
  "node_modules/react-grid-layout/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bottom = bottom;
    exports.childrenEqual = childrenEqual;
    exports.cloneLayout = cloneLayout;
    exports.cloneLayoutItem = cloneLayoutItem;
    exports.collides = collides;
    exports.compact = compact;
    exports.compactItem = compactItem;
    exports.compactType = compactType;
    exports.correctBounds = correctBounds;
    exports.fastPositionEqual = fastPositionEqual;
    exports.fastRGLPropsEqual = void 0;
    exports.getAllCollisions = getAllCollisions;
    exports.getFirstCollision = getFirstCollision;
    exports.getLayoutItem = getLayoutItem;
    exports.getStatics = getStatics;
    exports.modifyLayout = modifyLayout;
    exports.moveElement = moveElement;
    exports.moveElementAwayFromCollision = moveElementAwayFromCollision;
    exports.noop = void 0;
    exports.perc = perc;
    exports.setTopLeft = setTopLeft;
    exports.setTransform = setTransform;
    exports.sortLayoutItems = sortLayoutItems;
    exports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;
    exports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;
    exports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;
    exports.validateLayout = validateLayout;
    exports.withLayoutItem = withLayoutItem;
    var _lodash = _interopRequireDefault(require_lodash());
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var isProduction = false;
    var DEBUG = false;
    function bottom(layout) {
      var max = 0, bottomY;
      for (var i = 0, len = layout.length; i < len; i++) {
        bottomY = layout[i].y + layout[i].h;
        if (bottomY > max)
          max = bottomY;
      }
      return max;
    }
    function cloneLayout(layout) {
      var newLayout = Array(layout.length);
      for (var i = 0, len = layout.length; i < len; i++) {
        newLayout[i] = cloneLayoutItem(layout[i]);
      }
      return newLayout;
    }
    function modifyLayout(layout, layoutItem) {
      var newLayout = Array(layout.length);
      for (var i = 0, len = layout.length; i < len; i++) {
        if (layoutItem.i === layout[i].i) {
          newLayout[i] = layoutItem;
        } else {
          newLayout[i] = layout[i];
        }
      }
      return newLayout;
    }
    function withLayoutItem(layout, itemKey, cb) {
      var item = getLayoutItem(layout, itemKey);
      if (!item)
        return [layout, null];
      item = cb(cloneLayoutItem(item));
      layout = modifyLayout(layout, item);
      return [layout, item];
    }
    function cloneLayoutItem(layoutItem) {
      return {
        w: layoutItem.w,
        h: layoutItem.h,
        x: layoutItem.x,
        y: layoutItem.y,
        i: layoutItem.i,
        minW: layoutItem.minW,
        maxW: layoutItem.maxW,
        minH: layoutItem.minH,
        maxH: layoutItem.maxH,
        moved: Boolean(layoutItem.moved),
        static: Boolean(layoutItem.static),
        isDraggable: layoutItem.isDraggable,
        isResizable: layoutItem.isResizable,
        resizeHandles: layoutItem.resizeHandles,
        isBounded: layoutItem.isBounded
      };
    }
    function childrenEqual(a, b) {
      return (0, _lodash.default)(_react.default.Children.map(a, function(c) {
        return c === null || c === void 0 ? void 0 : c.key;
      }), _react.default.Children.map(b, function(c) {
        return c === null || c === void 0 ? void 0 : c.key;
      }));
    }
    var fastRGLPropsEqual = require_fastRGLPropsEqual();
    exports.fastRGLPropsEqual = fastRGLPropsEqual;
    function fastPositionEqual(a, b) {
      return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;
    }
    function collides(l1, l2) {
      if (l1.i === l2.i)
        return false;
      if (l1.x + l1.w <= l2.x)
        return false;
      if (l1.x >= l2.x + l2.w)
        return false;
      if (l1.y + l1.h <= l2.y)
        return false;
      if (l1.y >= l2.y + l2.h)
        return false;
      return true;
    }
    function compact(layout, compactType2, cols) {
      var compareWith = getStatics(layout);
      var sorted = sortLayoutItems(layout, compactType2);
      var out = Array(layout.length);
      for (var i = 0, len = sorted.length; i < len; i++) {
        var l = cloneLayoutItem(sorted[i]);
        if (!l.static) {
          l = compactItem(compareWith, l, compactType2, cols, sorted);
          compareWith.push(l);
        }
        out[layout.indexOf(sorted[i])] = l;
        l.moved = false;
      }
      return out;
    }
    var heightWidth = {
      x: "w",
      y: "h"
    };
    function resolveCompactionCollision(layout, item, moveToCoord, axis) {
      var sizeProp = heightWidth[axis];
      item[axis] += 1;
      var itemIndex = layout.map(function(layoutItem) {
        return layoutItem.i;
      }).indexOf(item.i);
      for (var i = itemIndex + 1; i < layout.length; i++) {
        var otherItem = layout[i];
        if (otherItem.static)
          continue;
        if (otherItem.y > item.y + item.h)
          break;
        if (collides(item, otherItem)) {
          resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);
        }
      }
      item[axis] = moveToCoord;
    }
    function compactItem(compareWith, l, compactType2, cols, fullLayout) {
      var compactV = compactType2 === "vertical";
      var compactH = compactType2 === "horizontal";
      if (compactV) {
        l.y = Math.min(bottom(compareWith), l.y);
        while (l.y > 0 && !getFirstCollision(compareWith, l)) {
          l.y--;
        }
      } else if (compactH) {
        while (l.x > 0 && !getFirstCollision(compareWith, l)) {
          l.x--;
        }
      }
      var collides2;
      while (collides2 = getFirstCollision(compareWith, l)) {
        if (compactH) {
          resolveCompactionCollision(fullLayout, l, collides2.x + collides2.w, "x");
        } else {
          resolveCompactionCollision(fullLayout, l, collides2.y + collides2.h, "y");
        }
        if (compactH && l.x + l.w > cols) {
          l.x = cols - l.w;
          l.y++;
        }
      }
      l.y = Math.max(l.y, 0);
      l.x = Math.max(l.x, 0);
      return l;
    }
    function correctBounds(layout, bounds) {
      var collidesWith = getStatics(layout);
      for (var i = 0, len = layout.length; i < len; i++) {
        var l = layout[i];
        if (l.x + l.w > bounds.cols)
          l.x = bounds.cols - l.w;
        if (l.x < 0) {
          l.x = 0;
          l.w = bounds.cols;
        }
        if (!l.static)
          collidesWith.push(l);
        else {
          while (getFirstCollision(collidesWith, l)) {
            l.y++;
          }
        }
      }
      return layout;
    }
    function getLayoutItem(layout, id) {
      for (var i = 0, len = layout.length; i < len; i++) {
        if (layout[i].i === id)
          return layout[i];
      }
    }
    function getFirstCollision(layout, layoutItem) {
      for (var i = 0, len = layout.length; i < len; i++) {
        if (collides(layout[i], layoutItem))
          return layout[i];
      }
    }
    function getAllCollisions(layout, layoutItem) {
      return layout.filter(function(l) {
        return collides(l, layoutItem);
      });
    }
    function getStatics(layout) {
      return layout.filter(function(l) {
        return l.static;
      });
    }
    function moveElement(layout, l, x, y, isUserAction, preventCollision, compactType2, cols, allowOverlap) {
      if (l.static && l.isDraggable !== true)
        return layout;
      if (l.y === y && l.x === x)
        return layout;
      log("Moving element ".concat(l.i, " to [").concat(String(x), ",").concat(String(y), "] from [").concat(l.x, ",").concat(l.y, "]"));
      var oldX = l.x;
      var oldY = l.y;
      if (typeof x === "number")
        l.x = x;
      if (typeof y === "number")
        l.y = y;
      l.moved = true;
      var sorted = sortLayoutItems(layout, compactType2);
      var movingUp = compactType2 === "vertical" && typeof y === "number" ? oldY >= y : compactType2 === "horizontal" && typeof x === "number" ? oldX >= x : false;
      if (movingUp)
        sorted = sorted.reverse();
      var collisions = getAllCollisions(sorted, l);
      var hasCollisions = collisions.length > 0;
      if (hasCollisions && allowOverlap) {
        return cloneLayout(layout);
      } else if (hasCollisions && preventCollision) {
        log("Collision prevented on ".concat(l.i, ", reverting."));
        l.x = oldX;
        l.y = oldY;
        l.moved = false;
        return layout;
      }
      for (var i = 0, len = collisions.length; i < len; i++) {
        var collision = collisions[i];
        log("Resolving collision between ".concat(l.i, " at [").concat(l.x, ",").concat(l.y, "] and ").concat(collision.i, " at [").concat(collision.x, ",").concat(collision.y, "]"));
        if (collision.moved)
          continue;
        if (collision.static) {
          layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType2, cols);
        } else {
          layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType2, cols);
        }
      }
      return layout;
    }
    function moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType2, cols) {
      var compactH = compactType2 === "horizontal";
      var compactV = compactType2 !== "horizontal";
      var preventCollision = collidesWith.static;
      if (isUserAction) {
        isUserAction = false;
        var fakeItem = {
          x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,
          y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,
          w: itemToMove.w,
          h: itemToMove.h,
          i: "-1"
        };
        if (!getFirstCollision(layout, fakeItem)) {
          log("Doing reverse collision on ".concat(itemToMove.i, " up to [").concat(fakeItem.x, ",").concat(fakeItem.y, "]."));
          return moveElement(layout, itemToMove, compactH ? fakeItem.x : void 0, compactV ? fakeItem.y : void 0, isUserAction, preventCollision, compactType2, cols);
        }
      }
      return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : void 0, compactV ? itemToMove.y + 1 : void 0, isUserAction, preventCollision, compactType2, cols);
    }
    function perc(num) {
      return num * 100 + "%";
    }
    function setTransform(_ref) {
      var top = _ref.top, left = _ref.left, width = _ref.width, height = _ref.height;
      var translate = "translate(".concat(left, "px,").concat(top, "px)");
      return {
        transform: translate,
        WebkitTransform: translate,
        MozTransform: translate,
        msTransform: translate,
        OTransform: translate,
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        position: "absolute"
      };
    }
    function setTopLeft(_ref2) {
      var top = _ref2.top, left = _ref2.left, width = _ref2.width, height = _ref2.height;
      return {
        top: "".concat(top, "px"),
        left: "".concat(left, "px"),
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        position: "absolute"
      };
    }
    function sortLayoutItems(layout, compactType2) {
      if (compactType2 === "horizontal")
        return sortLayoutItemsByColRow(layout);
      if (compactType2 === "vertical")
        return sortLayoutItemsByRowCol(layout);
      else
        return layout;
    }
    function sortLayoutItemsByRowCol(layout) {
      return layout.slice(0).sort(function(a, b) {
        if (a.y > b.y || a.y === b.y && a.x > b.x) {
          return 1;
        } else if (a.y === b.y && a.x === b.x) {
          return 0;
        }
        return -1;
      });
    }
    function sortLayoutItemsByColRow(layout) {
      return layout.slice(0).sort(function(a, b) {
        if (a.x > b.x || a.x === b.x && a.y > b.y) {
          return 1;
        }
        return -1;
      });
    }
    function synchronizeLayoutWithChildren(initialLayout, children, cols, compactType2, allowOverlap) {
      initialLayout = initialLayout || [];
      var layout = [];
      _react.default.Children.forEach(children, function(child) {
        if ((child === null || child === void 0 ? void 0 : child.key) == null)
          return;
        var exists = getLayoutItem(initialLayout, String(child.key));
        if (exists) {
          layout.push(cloneLayoutItem(exists));
        } else {
          if (!isProduction && child.props._grid) {
            console.warn("`_grid` properties on children have been deprecated as of React 15.2. Please use `data-grid` or add your properties directly to the `layout`.");
          }
          var g = child.props["data-grid"] || child.props._grid;
          if (g) {
            if (!isProduction) {
              validateLayout([g], "ReactGridLayout.children");
            }
            layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {
              i: child.key
            })));
          } else {
            layout.push(cloneLayoutItem({
              w: 1,
              h: 1,
              x: 0,
              y: bottom(layout),
              i: String(child.key)
            }));
          }
        }
      });
      var correctedLayout = correctBounds(layout, {
        cols
      });
      return allowOverlap ? correctedLayout : compact(correctedLayout, compactType2, cols);
    }
    function validateLayout(layout) {
      var contextName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Layout";
      var subProps = ["x", "y", "w", "h"];
      if (!Array.isArray(layout))
        throw new Error(contextName + " must be an array!");
      for (var i = 0, len = layout.length; i < len; i++) {
        var item = layout[i];
        for (var j = 0; j < subProps.length; j++) {
          if (typeof item[subProps[j]] !== "number") {
            throw new Error("ReactGridLayout: " + contextName + "[" + i + "]." + subProps[j] + " must be a number!");
          }
        }
      }
    }
    function compactType(props) {
      var _ref3 = props || {}, verticalCompact = _ref3.verticalCompact, compactType2 = _ref3.compactType;
      return verticalCompact === false ? null : compactType2;
    }
    function log() {
      var _console;
      if (!DEBUG)
        return;
      (_console = console).log.apply(_console, arguments);
    }
    var noop = function noop2() {
    };
    exports.noop = noop;
  }
});

// node_modules/react-grid-layout/build/calculateUtils.js
var require_calculateUtils = __commonJS({
  "node_modules/react-grid-layout/build/calculateUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.calcGridColWidth = calcGridColWidth;
    exports.calcGridItemPosition = calcGridItemPosition;
    exports.calcGridItemWHPx = calcGridItemWHPx;
    exports.calcWH = calcWH;
    exports.calcXY = calcXY;
    exports.clamp = clamp;
    function calcGridColWidth(positionParams) {
      var margin = positionParams.margin, containerPadding = positionParams.containerPadding, containerWidth = positionParams.containerWidth, cols = positionParams.cols;
      return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;
    }
    function calcGridItemWHPx(gridUnits, colOrRowSize, marginPx) {
      if (!Number.isFinite(gridUnits))
        return gridUnits;
      return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);
    }
    function calcGridItemPosition(positionParams, x, y, w, h, state) {
      var margin = positionParams.margin, containerPadding = positionParams.containerPadding, rowHeight = positionParams.rowHeight;
      var colWidth = calcGridColWidth(positionParams);
      var out = {};
      if (state && state.resizing) {
        out.width = Math.round(state.resizing.width);
        out.height = Math.round(state.resizing.height);
      } else {
        out.width = calcGridItemWHPx(w, colWidth, margin[0]);
        out.height = calcGridItemWHPx(h, rowHeight, margin[1]);
      }
      if (state && state.dragging) {
        out.top = Math.round(state.dragging.top);
        out.left = Math.round(state.dragging.left);
      } else {
        out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);
        out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);
      }
      return out;
    }
    function calcXY(positionParams, top, left, w, h) {
      var margin = positionParams.margin, cols = positionParams.cols, rowHeight = positionParams.rowHeight, maxRows = positionParams.maxRows;
      var colWidth = calcGridColWidth(positionParams);
      var x = Math.round((left - margin[0]) / (colWidth + margin[0]));
      var y = Math.round((top - margin[1]) / (rowHeight + margin[1]));
      x = clamp(x, 0, cols - w);
      y = clamp(y, 0, maxRows - h);
      return {
        x,
        y
      };
    }
    function calcWH(positionParams, width, height, x, y) {
      var margin = positionParams.margin, maxRows = positionParams.maxRows, cols = positionParams.cols, rowHeight = positionParams.rowHeight;
      var colWidth = calcGridColWidth(positionParams);
      var w = Math.round((width + margin[0]) / (colWidth + margin[0]));
      var h = Math.round((height + margin[1]) / (rowHeight + margin[1]));
      w = clamp(w, 0, cols - x);
      h = clamp(h, 0, maxRows - y);
      return {
        w,
        h
      };
    }
    function clamp(num, lowerBound, upperBound) {
      return Math.max(Math.min(num, upperBound), lowerBound);
    }
  }
});

// node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js
var clsx_m_exports2 = {};
__export(clsx_m_exports2, {
  clsx: () => clsx2,
  default: () => clsx_m_default2
});
function r2(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (f = r2(e[t])) && (n && (n += " "), n += f);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx2() {
  for (var e, t, f = 0, n = ""; f < arguments.length; )
    (e = arguments[f++]) && (t = r2(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default2;
var init_clsx_m2 = __esm({
  "node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default2 = clsx2;
  }
});

// node_modules/react-draggable/build/cjs/utils/shims.js
var require_shims = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/shims.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dontSetMe = dontSetMe;
    exports.findInArray = findInArray;
    exports.int = int;
    exports.isFunction = isFunction;
    exports.isNum = isNum;
    function findInArray(array, callback) {
      for (var i = 0, length = array.length; i < length; i++) {
        if (callback.apply(callback, [array[i], i, array]))
          return array[i];
      }
    }
    function isFunction(func) {
      return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
    }
    function isNum(num) {
      return typeof num === "number" && !isNaN(num);
    }
    function int(a) {
      return parseInt(a, 10);
    }
    function dontSetMe(props, propName, componentName) {
      if (props[propName]) {
        return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
      }
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/getPrefix.js
var require_getPrefix = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/getPrefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.browserPrefixToKey = browserPrefixToKey;
    exports.browserPrefixToStyle = browserPrefixToStyle;
    exports.default = void 0;
    exports.getPrefix = getPrefix;
    var prefixes = ["Moz", "Webkit", "O", "ms"];
    function getPrefix() {
      var _window$document, _window$document$docu;
      var prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      if (typeof window === "undefined")
        return "";
      var style = (_window$document = window.document) === null || _window$document === void 0 ? void 0 : (_window$document$docu = _window$document.documentElement) === null || _window$document$docu === void 0 ? void 0 : _window$document$docu.style;
      if (!style)
        return "";
      if (prop in style)
        return "";
      for (var i = 0; i < prefixes.length; i++) {
        if (browserPrefixToKey(prop, prefixes[i]) in style)
          return prefixes[i];
      }
      return "";
    }
    function browserPrefixToKey(prop, prefix) {
      return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
    }
    function browserPrefixToStyle(prop, prefix) {
      return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
    }
    function kebabToTitleCase(str) {
      var out = "";
      var shouldCapitalize = true;
      for (var i = 0; i < str.length; i++) {
        if (shouldCapitalize) {
          out += str[i].toUpperCase();
          shouldCapitalize = false;
        } else if (str[i] === "-") {
          shouldCapitalize = true;
        } else {
          out += str[i];
        }
      }
      return out;
    }
    var _default = getPrefix();
    exports.default = _default;
  }
});

// node_modules/react-draggable/build/cjs/utils/domFns.js
var require_domFns = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/domFns.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addClassName = addClassName;
    exports.addEvent = addEvent;
    exports.addUserSelectStyles = addUserSelectStyles;
    exports.createCSSTransform = createCSSTransform;
    exports.createSVGTransform = createSVGTransform;
    exports.getTouch = getTouch;
    exports.getTouchIdentifier = getTouchIdentifier;
    exports.getTranslation = getTranslation;
    exports.innerHeight = innerHeight;
    exports.innerWidth = innerWidth;
    exports.matchesSelector = matchesSelector;
    exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
    exports.offsetXYFromParent = offsetXYFromParent;
    exports.outerHeight = outerHeight;
    exports.outerWidth = outerWidth;
    exports.removeClassName = removeClassName;
    exports.removeEvent = removeEvent;
    exports.removeUserSelectStyles = removeUserSelectStyles;
    var _shims = require_shims();
    var _getPrefix = _interopRequireWildcard(require_getPrefix());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var matchesSelectorFunc = "";
    function matchesSelector(el, selector) {
      if (!matchesSelectorFunc) {
        matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
          return (0, _shims.isFunction)(el[method]);
        });
      }
      if (!(0, _shims.isFunction)(el[matchesSelectorFunc]))
        return false;
      return el[matchesSelectorFunc](selector);
    }
    function matchesSelectorAndParentsTo(el, selector, baseNode) {
      var node = el;
      do {
        if (matchesSelector(node, selector))
          return true;
        if (node === baseNode)
          return false;
        node = node.parentNode;
      } while (node);
      return false;
    }
    function addEvent(el, event, handler, inputOptions) {
      if (!el)
        return;
      var options = _objectSpread({
        capture: true
      }, inputOptions);
      if (el.addEventListener) {
        el.addEventListener(event, handler, options);
      } else if (el.attachEvent) {
        el.attachEvent("on" + event, handler);
      } else {
        el["on" + event] = handler;
      }
    }
    function removeEvent(el, event, handler, inputOptions) {
      if (!el)
        return;
      var options = _objectSpread({
        capture: true
      }, inputOptions);
      if (el.removeEventListener) {
        el.removeEventListener(event, handler, options);
      } else if (el.detachEvent) {
        el.detachEvent("on" + event, handler);
      } else {
        el["on" + event] = null;
      }
    }
    function outerHeight(node) {
      var height = node.clientHeight;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height += (0, _shims.int)(computedStyle.borderTopWidth);
      height += (0, _shims.int)(computedStyle.borderBottomWidth);
      return height;
    }
    function outerWidth(node) {
      var width = node.clientWidth;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width += (0, _shims.int)(computedStyle.borderLeftWidth);
      width += (0, _shims.int)(computedStyle.borderRightWidth);
      return width;
    }
    function innerHeight(node) {
      var height = node.clientHeight;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height -= (0, _shims.int)(computedStyle.paddingTop);
      height -= (0, _shims.int)(computedStyle.paddingBottom);
      return height;
    }
    function innerWidth(node) {
      var width = node.clientWidth;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width -= (0, _shims.int)(computedStyle.paddingLeft);
      width -= (0, _shims.int)(computedStyle.paddingRight);
      return width;
    }
    function offsetXYFromParent(evt, offsetParent, scale) {
      var isBody = offsetParent === offsetParent.ownerDocument.body;
      var offsetParentRect = isBody ? {
        left: 0,
        top: 0
      } : offsetParent.getBoundingClientRect();
      var x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
      var y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
      return {
        x,
        y
      };
    }
    function createCSSTransform(controlPos, positionOffset) {
      var translation = getTranslation(controlPos, positionOffset, "px");
      return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default), translation);
    }
    function createSVGTransform(controlPos, positionOffset) {
      var translation = getTranslation(controlPos, positionOffset, "");
      return translation;
    }
    function getTranslation(_ref2, positionOffset, unitSuffix) {
      var x = _ref2.x, y = _ref2.y;
      var translation = "translate(".concat(x).concat(unitSuffix, ",").concat(y).concat(unitSuffix, ")");
      if (positionOffset) {
        var defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
        var defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
        translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
      }
      return translation;
    }
    function getTouch(e, identifier) {
      return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function(t) {
        return identifier === t.identifier;
      }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function(t) {
        return identifier === t.identifier;
      });
    }
    function getTouchIdentifier(e) {
      if (e.targetTouches && e.targetTouches[0])
        return e.targetTouches[0].identifier;
      if (e.changedTouches && e.changedTouches[0])
        return e.changedTouches[0].identifier;
    }
    function addUserSelectStyles(doc) {
      if (!doc)
        return;
      var styleEl = doc.getElementById("react-draggable-style-el");
      if (!styleEl) {
        styleEl = doc.createElement("style");
        styleEl.type = "text/css";
        styleEl.id = "react-draggable-style-el";
        styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
        styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
        doc.getElementsByTagName("head")[0].appendChild(styleEl);
      }
      if (doc.body)
        addClassName(doc.body, "react-draggable-transparent-selection");
    }
    function removeUserSelectStyles(doc) {
      if (!doc)
        return;
      try {
        if (doc.body)
          removeClassName(doc.body, "react-draggable-transparent-selection");
        if (doc.selection) {
          doc.selection.empty();
        } else {
          var selection = (doc.defaultView || window).getSelection();
          if (selection && selection.type !== "Caret") {
            selection.removeAllRanges();
          }
        }
      } catch (e) {
      }
    }
    function addClassName(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
          el.className += " ".concat(className);
        }
      }
    }
    function removeClassName(el, className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
      }
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/positionFns.js
var require_positionFns = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/positionFns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.canDragX = canDragX;
    exports.canDragY = canDragY;
    exports.createCoreData = createCoreData;
    exports.createDraggableData = createDraggableData;
    exports.getBoundPosition = getBoundPosition;
    exports.getControlPosition = getControlPosition;
    exports.snapToGrid = snapToGrid;
    var _shims = require_shims();
    var _domFns = require_domFns();
    function getBoundPosition(draggable, x, y) {
      if (!draggable.props.bounds)
        return [x, y];
      var bounds = draggable.props.bounds;
      bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
      var node = findDOMNode(draggable);
      if (typeof bounds === "string") {
        var ownerDocument = node.ownerDocument;
        var ownerWindow = ownerDocument.defaultView;
        var boundNode;
        if (bounds === "parent") {
          boundNode = node.parentNode;
        } else {
          boundNode = ownerDocument.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) {
          throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        }
        var boundNodeEl = boundNode;
        var nodeStyle = ownerWindow.getComputedStyle(node);
        var boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        bounds = {
          left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
          top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
          right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
          bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
      }
      if ((0, _shims.isNum)(bounds.right))
        x = Math.min(x, bounds.right);
      if ((0, _shims.isNum)(bounds.bottom))
        y = Math.min(y, bounds.bottom);
      if ((0, _shims.isNum)(bounds.left))
        x = Math.max(x, bounds.left);
      if ((0, _shims.isNum)(bounds.top))
        y = Math.max(y, bounds.top);
      return [x, y];
    }
    function snapToGrid(grid, pendingX, pendingY) {
      var x = Math.round(pendingX / grid[0]) * grid[0];
      var y = Math.round(pendingY / grid[1]) * grid[1];
      return [x, y];
    }
    function canDragX(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "x";
    }
    function canDragY(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "y";
    }
    function getControlPosition(e, touchIdentifier, draggableCore) {
      var touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
      if (typeof touchIdentifier === "number" && !touchObj)
        return null;
      var node = findDOMNode(draggableCore);
      var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
      return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
    }
    function createCoreData(draggable, x, y) {
      var state = draggable.state;
      var isStart = !(0, _shims.isNum)(state.lastX);
      var node = findDOMNode(draggable);
      if (isStart) {
        return {
          node,
          deltaX: 0,
          deltaY: 0,
          lastX: x,
          lastY: y,
          x,
          y
        };
      } else {
        return {
          node,
          deltaX: x - state.lastX,
          deltaY: y - state.lastY,
          lastX: state.lastX,
          lastY: state.lastY,
          x,
          y
        };
      }
    }
    function createDraggableData(draggable, coreData) {
      var scale = draggable.props.scale;
      return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
      };
    }
    function cloneBounds(bounds) {
      return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
      };
    }
    function findDOMNode(draggable) {
      var node = draggable.findDOMNode();
      if (!node) {
        throw new Error("<DraggableCore>: Unmounted during event!");
      }
      return node;
    }
  }
});

// node_modules/react-draggable/build/cjs/utils/log.js
var require_log = __commonJS({
  "node_modules/react-draggable/build/cjs/utils/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = log;
    function log() {
      var _console;
      if (void 0)
        (_console = console).log.apply(_console, arguments);
    }
  }
});

// node_modules/react-draggable/build/cjs/DraggableCore.js
var require_DraggableCore = __commonJS({
  "node_modules/react-draggable/build/cjs/DraggableCore.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _log = _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var eventsFor = {
      touch: {
        start: "touchstart",
        move: "touchmove",
        stop: "touchend"
      },
      mouse: {
        start: "mousedown",
        move: "mousemove",
        stop: "mouseup"
      }
    };
    var dragEventFor = eventsFor.mouse;
    var DraggableCore = function(_React$Component) {
      _inherits(DraggableCore2, _React$Component);
      var _super = _createSuper(DraggableCore2);
      function DraggableCore2() {
        var _this;
        _classCallCheck(this, DraggableCore2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          dragging: false,
          lastX: NaN,
          lastY: NaN,
          touchIdentifier: null
        });
        _defineProperty(_assertThisInitialized(_this), "mounted", false);
        _defineProperty(_assertThisInitialized(_this), "handleDragStart", function(e) {
          _this.props.onMouseDown(e);
          if (!_this.props.allowAnyClick && typeof e.button === "number" && e.button !== 0)
            return false;
          var thisNode = _this.findDOMNode();
          if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
            throw new Error("<DraggableCore> not mounted on DragStart!");
          }
          var ownerDocument = thisNode.ownerDocument;
          if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, thisNode)) {
            return;
          }
          if (e.type === "touchstart")
            e.preventDefault();
          var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
          _this.setState({
            touchIdentifier
          });
          var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _assertThisInitialized(_this));
          if (position == null)
            return;
          var x = position.x, y = position.y;
          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
          (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
          (0, _log.default)("calling", _this.props.onStart);
          var shouldUpdate = _this.props.onStart(e, coreEvent);
          if (shouldUpdate === false || _this.mounted === false)
            return;
          if (_this.props.enableUserSelectHack)
            (0, _domFns.addUserSelectStyles)(ownerDocument);
          _this.setState({
            dragging: true,
            lastX: x,
            lastY: y
          });
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
        });
        _defineProperty(_assertThisInitialized(_this), "handleDrag", function(e) {
          var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));
          if (position == null)
            return;
          var x = position.x, y = position.y;
          if (Array.isArray(_this.props.grid)) {
            var deltaX = x - _this.state.lastX, deltaY = y - _this.state.lastY;
            var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
            var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);
            deltaX = _snapToGrid2[0];
            deltaY = _snapToGrid2[1];
            if (!deltaX && !deltaY)
              return;
            x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
          }
          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
          (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
          var shouldUpdate = _this.props.onDrag(e, coreEvent);
          if (shouldUpdate === false || _this.mounted === false) {
            try {
              _this.handleDragStop(new MouseEvent("mouseup"));
            } catch (err) {
              var event = document.createEvent("MouseEvents");
              event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
              _this.handleDragStop(event);
            }
            return;
          }
          _this.setState({
            lastX: x,
            lastY: y
          });
        });
        _defineProperty(_assertThisInitialized(_this), "handleDragStop", function(e) {
          if (!_this.state.dragging)
            return;
          var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _assertThisInitialized(_this));
          if (position == null)
            return;
          var x = position.x, y = position.y;
          if (Array.isArray(_this.props.grid)) {
            var deltaX = x - _this.state.lastX || 0;
            var deltaY = y - _this.state.lastY || 0;
            var _snapToGrid3 = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
            var _snapToGrid4 = _slicedToArray(_snapToGrid3, 2);
            deltaX = _snapToGrid4[0];
            deltaY = _snapToGrid4[1];
            x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
          }
          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x, y);
          var shouldContinue = _this.props.onStop(e, coreEvent);
          if (shouldContinue === false || _this.mounted === false)
            return false;
          var thisNode = _this.findDOMNode();
          if (thisNode) {
            if (_this.props.enableUserSelectHack)
              (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
          }
          (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
          _this.setState({
            dragging: false,
            lastX: NaN,
            lastY: NaN
          });
          if (thisNode) {
            (0, _log.default)("DraggableCore: Removing handlers");
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseDown", function(e) {
          dragEventFor = eventsFor.mouse;
          return _this.handleDragStart(e);
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseUp", function(e) {
          dragEventFor = eventsFor.mouse;
          return _this.handleDragStop(e);
        });
        _defineProperty(_assertThisInitialized(_this), "onTouchStart", function(e) {
          dragEventFor = eventsFor.touch;
          return _this.handleDragStart(e);
        });
        _defineProperty(_assertThisInitialized(_this), "onTouchEnd", function(e) {
          dragEventFor = eventsFor.touch;
          return _this.handleDragStop(e);
        });
        return _this;
      }
      _createClass(DraggableCore2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.mounted = true;
          var thisNode = this.findDOMNode();
          if (thisNode) {
            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
              passive: false
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.mounted = false;
          var thisNode = this.findDOMNode();
          if (thisNode) {
            var ownerDocument = thisNode.ownerDocument;
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
              passive: false
            });
            if (this.props.enableUserSelectHack)
              (0, _domFns.removeUserSelectStyles)(ownerDocument);
          }
        }
      }, {
        key: "findDOMNode",
        value: function findDOMNode() {
          var _this$props, _this$props2, _this$props2$nodeRef;
          return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 ? void 0 : (_this$props2$nodeRef = _this$props2.nodeRef) === null || _this$props2$nodeRef === void 0 ? void 0 : _this$props2$nodeRef.current : _reactDom.default.findDOMNode(this);
        }
      }, {
        key: "render",
        value: function render() {
          return React.cloneElement(React.Children.only(this.props.children), {
            onMouseDown: this.onMouseDown,
            onMouseUp: this.onMouseUp,
            onTouchEnd: this.onTouchEnd
          });
        }
      }]);
      return DraggableCore2;
    }(React.Component);
    exports.default = DraggableCore;
    _defineProperty(DraggableCore, "displayName", "DraggableCore");
    _defineProperty(DraggableCore, "propTypes", {
      allowAnyClick: _propTypes.default.bool,
      disabled: _propTypes.default.bool,
      enableUserSelectHack: _propTypes.default.bool,
      offsetParent: function offsetParent(props, propName) {
        if (props[propName] && props[propName].nodeType !== 1) {
          throw new Error("Draggable's offsetParent must be a DOM Node.");
        }
      },
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      handle: _propTypes.default.string,
      cancel: _propTypes.default.string,
      nodeRef: _propTypes.default.object,
      onStart: _propTypes.default.func,
      onDrag: _propTypes.default.func,
      onStop: _propTypes.default.func,
      onMouseDown: _propTypes.default.func,
      scale: _propTypes.default.number,
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(DraggableCore, "defaultProps", {
      allowAnyClick: false,
      disabled: false,
      enableUserSelectHack: true,
      onStart: function onStart() {
      },
      onDrag: function onDrag() {
      },
      onStop: function onStop() {
      },
      onMouseDown: function onMouseDown() {
      },
      scale: 1
    });
  }
});

// node_modules/react-draggable/build/cjs/Draggable.js
var require_Draggable = __commonJS({
  "node_modules/react-draggable/build/cjs/Draggable.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DraggableCore", {
      enumerable: true,
      get: function get() {
        return _DraggableCore.default;
      }
    });
    exports.default = void 0;
    var React = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _clsx2 = _interopRequireDefault((init_clsx_m2(), __toCommonJS(clsx_m_exports2)));
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _DraggableCore = _interopRequireDefault(require_DraggableCore());
    var _log = _interopRequireDefault(require_log());
    var _excluded = ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Draggable = function(_React$Component) {
      _inherits(Draggable2, _React$Component);
      var _super = _createSuper(Draggable2);
      function Draggable2(props) {
        var _this;
        _classCallCheck(this, Draggable2);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "onDragStart", function(e, coreData) {
          (0, _log.default)("Draggable: onDragStart: %j", coreData);
          var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));
          if (shouldStart === false)
            return false;
          _this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onDrag", function(e, coreData) {
          if (!_this.state.dragging)
            return false;
          (0, _log.default)("Draggable: onDrag: %j", coreData);
          var uiData = (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData);
          var newState = {
            x: uiData.x,
            y: uiData.y
          };
          if (_this.props.bounds) {
            var x = newState.x, y = newState.y;
            newState.x += _this.state.slackX;
            newState.y += _this.state.slackY;
            var _getBoundPosition = (0, _positionFns.getBoundPosition)(_assertThisInitialized(_this), newState.x, newState.y), _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2), newStateX = _getBoundPosition2[0], newStateY = _getBoundPosition2[1];
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = _this.state.slackX + (x - newState.x);
            newState.slackY = _this.state.slackY + (y - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - _this.state.x;
            uiData.deltaY = newState.y - _this.state.y;
          }
          var shouldUpdate = _this.props.onDrag(e, uiData);
          if (shouldUpdate === false)
            return false;
          _this.setState(newState);
        });
        _defineProperty(_assertThisInitialized(_this), "onDragStop", function(e, coreData) {
          if (!_this.state.dragging)
            return false;
          var shouldContinue = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));
          if (shouldContinue === false)
            return false;
          (0, _log.default)("Draggable: onDragStop: %j", coreData);
          var newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          var controlled = Boolean(_this.props.position);
          if (controlled) {
            var _this$props$position = _this.props.position, x = _this$props$position.x, y = _this$props$position.y;
            newState.x = x;
            newState.y = y;
          }
          _this.setState(newState);
        });
        _this.state = {
          dragging: false,
          dragged: false,
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: _objectSpread({}, props.position),
          slackX: 0,
          slackY: 0,
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
        return _this;
      }
      _createClass(Draggable2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
            this.setState({
              isElementSVG: true
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.setState({
            dragging: false
          });
        }
      }, {
        key: "findDOMNode",
        value: function findDOMNode() {
          var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;
          return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
        }
      }, {
        key: "render",
        value: function render() {
          var _clsx;
          var _this$props2 = this.props, axis = _this$props2.axis, bounds = _this$props2.bounds, children = _this$props2.children, defaultPosition = _this$props2.defaultPosition, defaultClassName = _this$props2.defaultClassName, defaultClassNameDragging = _this$props2.defaultClassNameDragging, defaultClassNameDragged = _this$props2.defaultClassNameDragged, position = _this$props2.position, positionOffset = _this$props2.positionOffset, scale = _this$props2.scale, draggableCoreProps = _objectWithoutProperties(_this$props2, _excluded);
          var style = {};
          var svgTransform = null;
          var controlled = Boolean(position);
          var draggable = !controlled || this.state.dragging;
          var validPosition = position || defaultPosition;
          var transformOpts = {
            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
          };
          if (this.state.isElementSVG) {
            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
          } else {
            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
          }
          var className = (0, _clsx2.default)(children.props.className || "", defaultClassName, (_clsx = {}, _defineProperty(_clsx, defaultClassNameDragging, this.state.dragging), _defineProperty(_clsx, defaultClassNameDragged, this.state.dragged), _clsx));
          return React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop
          }), React.cloneElement(React.Children.only(children), {
            className,
            style: _objectSpread(_objectSpread({}, children.props.style), style),
            transform: svgTransform
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(_ref, _ref2) {
          var position = _ref.position;
          var prevPropsPosition = _ref2.prevPropsPosition;
          if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
            (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
              position,
              prevPropsPosition
            });
            return {
              x: position.x,
              y: position.y,
              prevPropsPosition: _objectSpread({}, position)
            };
          }
          return null;
        }
      }]);
      return Draggable2;
    }(React.Component);
    exports.default = Draggable;
    _defineProperty(Draggable, "displayName", "Draggable");
    _defineProperty(Draggable, "propTypes", _objectSpread(_objectSpread({}, _DraggableCore.default.propTypes), {}, {
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
        left: _propTypes.default.number,
        right: _propTypes.default.number,
        top: _propTypes.default.number,
        bottom: _propTypes.default.number
      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
      defaultClassName: _propTypes.default.string,
      defaultClassNameDragging: _propTypes.default.string,
      defaultClassNameDragged: _propTypes.default.string,
      defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
      }),
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    }));
    _defineProperty(Draggable, "defaultProps", _objectSpread(_objectSpread({}, _DraggableCore.default.defaultProps), {}, {
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    }));
  }
});

// node_modules/react-draggable/build/cjs/cjs.js
var require_cjs = __commonJS({
  "node_modules/react-draggable/build/cjs/cjs.js"(exports, module) {
    "use strict";
    var _require = require_Draggable();
    var Draggable = _require.default;
    var DraggableCore = _require.DraggableCore;
    module.exports = Draggable;
    module.exports.default = Draggable;
    module.exports.DraggableCore = DraggableCore;
  }
});

// node_modules/react-resizable/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/react-resizable/build/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.cloneElement = cloneElement;
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function cloneElement(element, props) {
      if (props.style && element.props.style) {
        props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);
      }
      if (props.className && element.props.className) {
        props.className = element.props.className + " " + props.className;
      }
      return _react.default.cloneElement(element, props);
    }
  }
});

// node_modules/react-resizable/build/propTypes.js
var require_propTypes = __commonJS({
  "node_modules/react-resizable/build/propTypes.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.resizableProps = void 0;
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDraggable = require_cjs();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var resizableProps = {
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      className: _propTypes.default.string,
      children: _propTypes.default.element.isRequired,
      draggableOpts: _propTypes.default.shape({
        allowAnyClick: _propTypes.default.bool,
        cancel: _propTypes.default.string,
        children: _propTypes.default.node,
        disabled: _propTypes.default.bool,
        enableUserSelectHack: _propTypes.default.bool,
        offsetParent: _propTypes.default.node,
        grid: _propTypes.default.arrayOf(_propTypes.default.number),
        handle: _propTypes.default.string,
        nodeRef: _propTypes.default.object,
        onStart: _propTypes.default.func,
        onDrag: _propTypes.default.func,
        onStop: _propTypes.default.func,
        onMouseDown: _propTypes.default.func,
        scale: _propTypes.default.number
      }),
      height: function height() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var props = args[0];
        if (props.axis === "both" || props.axis === "y") {
          var _PropTypes$number;
          return (_PropTypes$number = _propTypes.default.number).isRequired.apply(_PropTypes$number, args);
        }
        return _propTypes.default.number.apply(_propTypes.default, args);
      },
      handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
      handleSize: _propTypes.default.arrayOf(_propTypes.default.number),
      lockAspectRatio: _propTypes.default.bool,
      maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
      minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),
      onResizeStop: _propTypes.default.func,
      onResizeStart: _propTypes.default.func,
      onResize: _propTypes.default.func,
      resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(["s", "w", "e", "n", "sw", "nw", "se", "ne"])),
      transformScale: _propTypes.default.number,
      width: function width() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var props = args[0];
        if (props.axis === "both" || props.axis === "x") {
          var _PropTypes$number2;
          return (_PropTypes$number2 = _propTypes.default.number).isRequired.apply(_PropTypes$number2, args);
        }
        return _propTypes.default.number.apply(_propTypes.default, args);
      }
    };
    exports.resizableProps = resizableProps;
  }
});

// node_modules/react-resizable/build/Resizable.js
var require_Resizable = __commonJS({
  "node_modules/react-resizable/build/Resizable.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var React = _interopRequireWildcard(require_react());
    var _reactDraggable = require_cjs();
    var _utils = require_utils2();
    var _propTypes = require_propTypes();
    var _excluded = ["children", "className", "draggableOpts", "width", "height", "handle", "handleSize", "lockAspectRatio", "axis", "minConstraints", "maxConstraints", "onResize", "onResizeStop", "onResizeStart", "resizeHandles", "transformScale"];
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Resizable = function(_React$Component) {
      _inheritsLoose(Resizable2, _React$Component);
      function Resizable2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.handleRefs = {};
        _this.lastHandleRect = null;
        _this.slack = null;
        return _this;
      }
      var _proto = Resizable2.prototype;
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.resetData();
      };
      _proto.resetData = function resetData() {
        this.lastHandleRect = this.slack = null;
      };
      _proto.runConstraints = function runConstraints(width, height) {
        var _this$props = this.props, minConstraints = _this$props.minConstraints, maxConstraints = _this$props.maxConstraints, lockAspectRatio = _this$props.lockAspectRatio;
        if (!minConstraints && !maxConstraints && !lockAspectRatio)
          return [width, height];
        if (lockAspectRatio) {
          var ratio = this.props.width / this.props.height;
          var deltaW = width - this.props.width;
          var deltaH = height - this.props.height;
          if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {
            height = width / ratio;
          } else {
            width = height * ratio;
          }
        }
        var oldW = width, oldH = height;
        var _ref = this.slack || [0, 0], slackW = _ref[0], slackH = _ref[1];
        width += slackW;
        height += slackH;
        if (minConstraints) {
          width = Math.max(minConstraints[0], width);
          height = Math.max(minConstraints[1], height);
        }
        if (maxConstraints) {
          width = Math.min(maxConstraints[0], width);
          height = Math.min(maxConstraints[1], height);
        }
        this.slack = [slackW + (oldW - width), slackH + (oldH - height)];
        return [width, height];
      };
      _proto.resizeHandler = function resizeHandler(handlerName, axis) {
        var _this2 = this;
        return function(e, _ref2) {
          var node = _ref2.node, deltaX = _ref2.deltaX, deltaY = _ref2.deltaY;
          if (handlerName === "onResizeStart")
            _this2.resetData();
          var canDragX = (_this2.props.axis === "both" || _this2.props.axis === "x") && axis !== "n" && axis !== "s";
          var canDragY = (_this2.props.axis === "both" || _this2.props.axis === "y") && axis !== "e" && axis !== "w";
          if (!canDragX && !canDragY)
            return;
          var axisV = axis[0];
          var axisH = axis[axis.length - 1];
          var handleRect = node.getBoundingClientRect();
          if (_this2.lastHandleRect != null) {
            if (axisH === "w") {
              var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;
              deltaX += deltaLeftSinceLast;
            }
            if (axisV === "n") {
              var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;
              deltaY += deltaTopSinceLast;
            }
          }
          _this2.lastHandleRect = handleRect;
          if (axisH === "w")
            deltaX = -deltaX;
          if (axisV === "n")
            deltaY = -deltaY;
          var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);
          var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0);
          var _this2$runConstraints = _this2.runConstraints(width, height);
          width = _this2$runConstraints[0];
          height = _this2$runConstraints[1];
          var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height;
          var cb = typeof _this2.props[handlerName] === "function" ? _this2.props[handlerName] : null;
          var shouldSkipCb = handlerName === "onResize" && !dimensionsChanged;
          if (cb && !shouldSkipCb) {
            e.persist == null ? void 0 : e.persist();
            cb(e, {
              node,
              size: {
                width,
                height
              },
              handle: axis
            });
          }
          if (handlerName === "onResizeStop")
            _this2.resetData();
        };
      };
      _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {
        var handle = this.props.handle;
        if (!handle) {
          return React.createElement("span", {
            className: "react-resizable-handle react-resizable-handle-" + handleAxis,
            ref
          });
        }
        if (typeof handle === "function") {
          return handle(handleAxis, ref);
        }
        var isDOMElement = typeof handle.type === "string";
        var props = _objectSpread({
          ref
        }, isDOMElement ? {} : {
          handleAxis
        });
        return React.cloneElement(handle, props);
      };
      _proto.render = function render() {
        var _this3 = this;
        var _this$props2 = this.props, children = _this$props2.children, className = _this$props2.className, draggableOpts = _this$props2.draggableOpts, width = _this$props2.width, height = _this$props2.height, handle = _this$props2.handle, handleSize = _this$props2.handleSize, lockAspectRatio = _this$props2.lockAspectRatio, axis = _this$props2.axis, minConstraints = _this$props2.minConstraints, maxConstraints = _this$props2.maxConstraints, onResize = _this$props2.onResize, onResizeStop = _this$props2.onResizeStop, onResizeStart = _this$props2.onResizeStart, resizeHandles = _this$props2.resizeHandles, transformScale = _this$props2.transformScale, p = _objectWithoutPropertiesLoose(_this$props2, _excluded);
        return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {
          className: (className ? className + " " : "") + "react-resizable",
          children: [].concat(children.props.children, resizeHandles.map(function(handleAxis) {
            var _this3$handleRefs$han;
            var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = React.createRef();
            return React.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {
              nodeRef: ref,
              key: "resizableHandle-" + handleAxis,
              onStop: _this3.resizeHandler("onResizeStop", handleAxis),
              onStart: _this3.resizeHandler("onResizeStart", handleAxis),
              onDrag: _this3.resizeHandler("onResize", handleAxis)
            }), _this3.renderResizeHandle(handleAxis, ref));
          }))
        }));
      };
      return Resizable2;
    }(React.Component);
    exports.default = Resizable;
    Resizable.propTypes = _propTypes.resizableProps;
    Resizable.defaultProps = {
      axis: "both",
      handleSize: [20, 20],
      lockAspectRatio: false,
      minConstraints: [20, 20],
      maxConstraints: [Infinity, Infinity],
      resizeHandles: ["se"],
      transformScale: 1
    };
  }
});

// node_modules/react-resizable/build/ResizableBox.js
var require_ResizableBox = __commonJS({
  "node_modules/react-resizable/build/ResizableBox.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var React = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _Resizable = _interopRequireDefault(require_Resizable());
    var _propTypes2 = require_propTypes();
    var _excluded = ["handle", "handleSize", "onResize", "onResizeStart", "onResizeStop", "draggableOpts", "minConstraints", "maxConstraints", "lockAspectRatio", "axis", "width", "height", "resizeHandles", "style", "transformScale"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var ResizableBox = function(_React$Component) {
      _inheritsLoose(ResizableBox2, _React$Component);
      function ResizableBox2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.state = {
          width: _this.props.width,
          height: _this.props.height,
          propsWidth: _this.props.width,
          propsHeight: _this.props.height
        };
        _this.onResize = function(e, data) {
          var size = data.size;
          if (_this.props.onResize) {
            e.persist == null ? void 0 : e.persist();
            _this.setState(size, function() {
              return _this.props.onResize && _this.props.onResize(e, data);
            });
          } else {
            _this.setState(size);
          }
        };
        return _this;
      }
      ResizableBox2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        if (state.propsWidth !== props.width || state.propsHeight !== props.height) {
          return {
            width: props.width,
            height: props.height,
            propsWidth: props.width,
            propsHeight: props.height
          };
        }
        return null;
      };
      var _proto = ResizableBox2.prototype;
      _proto.render = function render() {
        var _this$props = this.props, handle = _this$props.handle, handleSize = _this$props.handleSize, onResize = _this$props.onResize, onResizeStart = _this$props.onResizeStart, onResizeStop = _this$props.onResizeStop, draggableOpts = _this$props.draggableOpts, minConstraints = _this$props.minConstraints, maxConstraints = _this$props.maxConstraints, lockAspectRatio = _this$props.lockAspectRatio, axis = _this$props.axis, width = _this$props.width, height = _this$props.height, resizeHandles = _this$props.resizeHandles, style = _this$props.style, transformScale = _this$props.transformScale, props = _objectWithoutPropertiesLoose(_this$props, _excluded);
        return React.createElement(_Resizable.default, {
          axis,
          draggableOpts,
          handle,
          handleSize,
          height: this.state.height,
          lockAspectRatio,
          maxConstraints,
          minConstraints,
          onResizeStart,
          onResize: this.onResize,
          onResizeStop,
          resizeHandles,
          transformScale,
          width: this.state.width
        }, React.createElement("div", _extends({}, props, {
          style: _objectSpread(_objectSpread({}, style), {}, {
            width: this.state.width + "px",
            height: this.state.height + "px"
          })
        })));
      };
      return ResizableBox2;
    }(React.Component);
    exports.default = ResizableBox;
    ResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {
      children: _propTypes.default.element
    });
  }
});

// node_modules/react-resizable/index.js
var require_react_resizable = __commonJS({
  "node_modules/react-resizable/index.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error("Don't instantiate Resizable directly! Use require('react-resizable').Resizable");
    };
    module.exports.Resizable = require_Resizable().default;
    module.exports.ResizableBox = require_ResizableBox().default;
  }
});

// node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js
var require_ReactGridLayoutPropTypes = __commonJS({
  "node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.resizeHandleType = exports.resizeHandleAxesType = exports.default = void 0;
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf(["s", "w", "e", "n", "sw", "nw", "se", "ne"]));
    exports.resizeHandleAxesType = resizeHandleAxesType;
    var resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);
    exports.resizeHandleType = resizeHandleType;
    var _default = {
      className: _propTypes.default.string,
      style: _propTypes.default.object,
      width: _propTypes.default.number,
      autoSize: _propTypes.default.bool,
      cols: _propTypes.default.number,
      draggableCancel: _propTypes.default.string,
      draggableHandle: _propTypes.default.string,
      verticalCompact: function verticalCompact(props) {
        if (props.verticalCompact === false && true) {
          console.warn(
            '`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. Use `compactType`: "horizontal" | "vertical" | null.'
          );
        }
      },
      compactType: _propTypes.default.oneOf(["vertical", "horizontal"]),
      layout: function layout(props) {
        var layout2 = props.layout;
        if (layout2 === void 0)
          return;
        require_utils().validateLayout(layout2, "layout");
      },
      margin: _propTypes.default.arrayOf(_propTypes.default.number),
      containerPadding: _propTypes.default.arrayOf(_propTypes.default.number),
      rowHeight: _propTypes.default.number,
      maxRows: _propTypes.default.number,
      isBounded: _propTypes.default.bool,
      isDraggable: _propTypes.default.bool,
      isResizable: _propTypes.default.bool,
      allowOverlap: _propTypes.default.bool,
      preventCollision: _propTypes.default.bool,
      useCSSTransforms: _propTypes.default.bool,
      transformScale: _propTypes.default.number,
      isDroppable: _propTypes.default.bool,
      resizeHandles: resizeHandleAxesType,
      resizeHandle: resizeHandleType,
      onLayoutChange: _propTypes.default.func,
      onDragStart: _propTypes.default.func,
      onDrag: _propTypes.default.func,
      onDragStop: _propTypes.default.func,
      onResizeStart: _propTypes.default.func,
      onResize: _propTypes.default.func,
      onResizeStop: _propTypes.default.func,
      onDrop: _propTypes.default.func,
      droppingItem: _propTypes.default.shape({
        i: _propTypes.default.string.isRequired,
        w: _propTypes.default.number.isRequired,
        h: _propTypes.default.number.isRequired
      }),
      children: function children(props, propName) {
        var children2 = props[propName];
        var keys = {};
        _react.default.Children.forEach(children2, function(child) {
          if ((child === null || child === void 0 ? void 0 : child.key) == null)
            return;
          if (keys[child.key]) {
            throw new Error('Duplicate child key "' + child.key + '" found! This will cause problems in ReactGridLayout.');
          }
          keys[child.key] = true;
        });
      },
      innerRef: _propTypes.default.any
    };
    exports.default = _default;
  }
});

// node_modules/react-grid-layout/build/GridItem.js
var require_GridItem = __commonJS({
  "node_modules/react-grid-layout/build/GridItem.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDraggable = require_cjs();
    var _reactResizable = require_react_resizable();
    var _utils = require_utils();
    var _calculateUtils = require_calculateUtils();
    var _ReactGridLayoutPropTypes = require_ReactGridLayoutPropTypes();
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var GridItem = function(_React$Component) {
      _inherits(GridItem2, _React$Component);
      var _super = _createSuper(GridItem2);
      function GridItem2() {
        var _this;
        _classCallCheck(this, GridItem2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          resizing: null,
          dragging: null,
          className: ""
        });
        _defineProperty(_assertThisInitialized(_this), "elementRef", _react.default.createRef());
        _defineProperty(_assertThisInitialized(_this), "onDragStart", function(e, _ref) {
          var node = _ref.node;
          var _this$props = _this.props, onDragStart = _this$props.onDragStart, transformScale = _this$props.transformScale;
          if (!onDragStart)
            return;
          var newPosition = {
            top: 0,
            left: 0
          };
          var offsetParent = node.offsetParent;
          if (!offsetParent)
            return;
          var parentRect = offsetParent.getBoundingClientRect();
          var clientRect = node.getBoundingClientRect();
          var cLeft = clientRect.left / transformScale;
          var pLeft = parentRect.left / transformScale;
          var cTop = clientRect.top / transformScale;
          var pTop = parentRect.top / transformScale;
          newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;
          newPosition.top = cTop - pTop + offsetParent.scrollTop;
          _this.setState({
            dragging: newPosition
          });
          var _calcXY = (0, _calculateUtils.calcXY)(_this.getPositionParams(), newPosition.top, newPosition.left, _this.props.w, _this.props.h), x = _calcXY.x, y = _calcXY.y;
          return onDragStart.call(_assertThisInitialized(_this), _this.props.i, x, y, {
            e,
            node,
            newPosition
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onDrag", function(e, _ref2) {
          var node = _ref2.node, deltaX = _ref2.deltaX, deltaY = _ref2.deltaY;
          var onDrag = _this.props.onDrag;
          if (!onDrag)
            return;
          if (!_this.state.dragging) {
            throw new Error("onDrag called before onDragStart.");
          }
          var top = _this.state.dragging.top + deltaY;
          var left = _this.state.dragging.left + deltaX;
          var _this$props2 = _this.props, isBounded = _this$props2.isBounded, i = _this$props2.i, w = _this$props2.w, h = _this$props2.h, containerWidth = _this$props2.containerWidth;
          var positionParams = _this.getPositionParams();
          if (isBounded) {
            var offsetParent = node.offsetParent;
            if (offsetParent) {
              var _this$props3 = _this.props, margin = _this$props3.margin, rowHeight = _this$props3.rowHeight;
              var bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);
              top = (0, _calculateUtils.clamp)(top, 0, bottomBoundary);
              var colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);
              var rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);
              left = (0, _calculateUtils.clamp)(left, 0, rightBoundary);
            }
          }
          var newPosition = {
            top,
            left
          };
          _this.setState({
            dragging: newPosition
          });
          var _calcXY2 = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h), x = _calcXY2.x, y = _calcXY2.y;
          return onDrag.call(_assertThisInitialized(_this), i, x, y, {
            e,
            node,
            newPosition
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onDragStop", function(e, _ref3) {
          var node = _ref3.node;
          var onDragStop = _this.props.onDragStop;
          if (!onDragStop)
            return;
          if (!_this.state.dragging) {
            throw new Error("onDragEnd called before onDragStart.");
          }
          var _this$props4 = _this.props, w = _this$props4.w, h = _this$props4.h, i = _this$props4.i;
          var _this$state$dragging = _this.state.dragging, left = _this$state$dragging.left, top = _this$state$dragging.top;
          var newPosition = {
            top,
            left
          };
          _this.setState({
            dragging: null
          });
          var _calcXY3 = (0, _calculateUtils.calcXY)(_this.getPositionParams(), top, left, w, h), x = _calcXY3.x, y = _calcXY3.y;
          return onDragStop.call(_assertThisInitialized(_this), i, x, y, {
            e,
            node,
            newPosition
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onResizeStop", function(e, callbackData) {
          _this.onResizeHandler(e, callbackData, "onResizeStop");
        });
        _defineProperty(_assertThisInitialized(_this), "onResizeStart", function(e, callbackData) {
          _this.onResizeHandler(e, callbackData, "onResizeStart");
        });
        _defineProperty(_assertThisInitialized(_this), "onResize", function(e, callbackData) {
          _this.onResizeHandler(e, callbackData, "onResize");
        });
        return _this;
      }
      _createClass(GridItem2, [{
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          if (this.props.children !== nextProps.children)
            return true;
          if (this.props.droppingPosition !== nextProps.droppingPosition)
            return true;
          var oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);
          var newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);
          return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.moveDroppingItem({});
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          this.moveDroppingItem(prevProps);
        }
      }, {
        key: "moveDroppingItem",
        value: function moveDroppingItem(prevProps) {
          var droppingPosition = this.props.droppingPosition;
          if (!droppingPosition)
            return;
          var node = this.elementRef.current;
          if (!node)
            return;
          var prevDroppingPosition = prevProps.droppingPosition || {
            left: 0,
            top: 0
          };
          var dragging = this.state.dragging;
          var shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;
          if (!dragging) {
            this.onDragStart(droppingPosition.e, {
              node,
              deltaX: droppingPosition.left,
              deltaY: droppingPosition.top
            });
          } else if (shouldDrag) {
            var deltaX = droppingPosition.left - dragging.left;
            var deltaY = droppingPosition.top - dragging.top;
            this.onDrag(droppingPosition.e, {
              node,
              deltaX,
              deltaY
            });
          }
        }
      }, {
        key: "getPositionParams",
        value: function getPositionParams() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          return {
            cols: props.cols,
            containerPadding: props.containerPadding,
            containerWidth: props.containerWidth,
            margin: props.margin,
            maxRows: props.maxRows,
            rowHeight: props.rowHeight
          };
        }
      }, {
        key: "createStyle",
        value: function createStyle(pos) {
          var _this$props5 = this.props, usePercentages = _this$props5.usePercentages, containerWidth = _this$props5.containerWidth, useCSSTransforms = _this$props5.useCSSTransforms;
          var style;
          if (useCSSTransforms) {
            style = (0, _utils.setTransform)(pos);
          } else {
            style = (0, _utils.setTopLeft)(pos);
            if (usePercentages) {
              style.left = (0, _utils.perc)(pos.left / containerWidth);
              style.width = (0, _utils.perc)(pos.width / containerWidth);
            }
          }
          return style;
        }
      }, {
        key: "mixinDraggable",
        value: function mixinDraggable(child, isDraggable) {
          return _react.default.createElement(_reactDraggable.DraggableCore, {
            disabled: !isDraggable,
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop,
            handle: this.props.handle,
            cancel: ".react-resizable-handle" + (this.props.cancel ? "," + this.props.cancel : ""),
            scale: this.props.transformScale,
            nodeRef: this.elementRef
          }, child);
        }
      }, {
        key: "mixinResizable",
        value: function mixinResizable(child, position, isResizable) {
          var _this$props6 = this.props, cols = _this$props6.cols, x = _this$props6.x, minW = _this$props6.minW, minH = _this$props6.minH, maxW = _this$props6.maxW, maxH = _this$props6.maxH, transformScale = _this$props6.transformScale, resizeHandles = _this$props6.resizeHandles, resizeHandle = _this$props6.resizeHandle;
          var positionParams = this.getPositionParams();
          var maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols - x, 0).width;
          var mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);
          var maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);
          var minConstraints = [mins.width, mins.height];
          var maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];
          return _react.default.createElement(
            _reactResizable.Resizable,
            {
              draggableOpts: {
                disabled: !isResizable
              },
              className: isResizable ? void 0 : "react-resizable-hide",
              width: position.width,
              height: position.height,
              minConstraints,
              maxConstraints,
              onResizeStop: this.onResizeStop,
              onResizeStart: this.onResizeStart,
              onResize: this.onResize,
              transformScale,
              resizeHandles,
              handle: resizeHandle
            },
            child
          );
        }
      }, {
        key: "onResizeHandler",
        value: function onResizeHandler(e, _ref4, handlerName) {
          var node = _ref4.node, size = _ref4.size;
          var handler = this.props[handlerName];
          if (!handler)
            return;
          var _this$props7 = this.props, cols = _this$props7.cols, x = _this$props7.x, y = _this$props7.y, i = _this$props7.i, maxH = _this$props7.maxH, minH = _this$props7.minH;
          var _this$props8 = this.props, minW = _this$props8.minW, maxW = _this$props8.maxW;
          var _calcWH = (0, _calculateUtils.calcWH)(this.getPositionParams(), size.width, size.height, x, y), w = _calcWH.w, h = _calcWH.h;
          minW = Math.max(minW, 1);
          maxW = Math.min(maxW, cols - x);
          w = (0, _calculateUtils.clamp)(w, minW, maxW);
          h = (0, _calculateUtils.clamp)(h, minH, maxH);
          this.setState({
            resizing: handlerName === "onResizeStop" ? null : size
          });
          handler.call(this, i, w, h, {
            e,
            node,
            size
          });
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props9 = this.props, x = _this$props9.x, y = _this$props9.y, w = _this$props9.w, h = _this$props9.h, isDraggable = _this$props9.isDraggable, isResizable = _this$props9.isResizable, droppingPosition = _this$props9.droppingPosition, useCSSTransforms = _this$props9.useCSSTransforms;
          var pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);
          var child = _react.default.Children.only(this.props.children);
          var newChild = _react.default.cloneElement(child, {
            ref: this.elementRef,
            className: (0, _clsx.default)("react-grid-item", child.props.className, this.props.className, {
              static: this.props.static,
              resizing: Boolean(this.state.resizing),
              "react-draggable": isDraggable,
              "react-draggable-dragging": Boolean(this.state.dragging),
              dropping: Boolean(droppingPosition),
              cssTransforms: useCSSTransforms
            }),
            style: _objectSpread(_objectSpread(_objectSpread({}, this.props.style), child.props.style), this.createStyle(pos))
          });
          newChild = this.mixinResizable(newChild, pos, isResizable);
          newChild = this.mixinDraggable(newChild, isDraggable);
          return newChild;
        }
      }]);
      return GridItem2;
    }(_react.default.Component);
    exports.default = GridItem;
    _defineProperty(GridItem, "propTypes", {
      children: _propTypes.default.element,
      cols: _propTypes.default.number.isRequired,
      containerWidth: _propTypes.default.number.isRequired,
      rowHeight: _propTypes.default.number.isRequired,
      margin: _propTypes.default.array.isRequired,
      maxRows: _propTypes.default.number.isRequired,
      containerPadding: _propTypes.default.array.isRequired,
      x: _propTypes.default.number.isRequired,
      y: _propTypes.default.number.isRequired,
      w: _propTypes.default.number.isRequired,
      h: _propTypes.default.number.isRequired,
      minW: function minW(props, propName) {
        var value = props[propName];
        if (typeof value !== "number")
          return new Error("minWidth not Number");
        if (value > props.w || value > props.maxW)
          return new Error("minWidth larger than item width/maxWidth");
      },
      maxW: function maxW(props, propName) {
        var value = props[propName];
        if (typeof value !== "number")
          return new Error("maxWidth not Number");
        if (value < props.w || value < props.minW)
          return new Error("maxWidth smaller than item width/minWidth");
      },
      minH: function minH(props, propName) {
        var value = props[propName];
        if (typeof value !== "number")
          return new Error("minHeight not Number");
        if (value > props.h || value > props.maxH)
          return new Error("minHeight larger than item height/maxHeight");
      },
      maxH: function maxH(props, propName) {
        var value = props[propName];
        if (typeof value !== "number")
          return new Error("maxHeight not Number");
        if (value < props.h || value < props.minH)
          return new Error("maxHeight smaller than item height/minHeight");
      },
      i: _propTypes.default.string.isRequired,
      resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,
      resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,
      onDragStop: _propTypes.default.func,
      onDragStart: _propTypes.default.func,
      onDrag: _propTypes.default.func,
      onResizeStop: _propTypes.default.func,
      onResizeStart: _propTypes.default.func,
      onResize: _propTypes.default.func,
      isDraggable: _propTypes.default.bool.isRequired,
      isResizable: _propTypes.default.bool.isRequired,
      isBounded: _propTypes.default.bool.isRequired,
      static: _propTypes.default.bool,
      useCSSTransforms: _propTypes.default.bool.isRequired,
      transformScale: _propTypes.default.number,
      className: _propTypes.default.string,
      handle: _propTypes.default.string,
      cancel: _propTypes.default.string,
      droppingPosition: _propTypes.default.shape({
        e: _propTypes.default.object.isRequired,
        left: _propTypes.default.number.isRequired,
        top: _propTypes.default.number.isRequired
      })
    });
    _defineProperty(GridItem, "defaultProps", {
      className: "",
      cancel: "",
      handle: "",
      minH: 1,
      minW: 1,
      maxH: Infinity,
      maxW: Infinity,
      transformScale: 1
    });
  }
});

// node_modules/react-grid-layout/build/ReactGridLayout.js
var require_ReactGridLayout = __commonJS({
  "node_modules/react-grid-layout/build/ReactGridLayout.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React = _interopRequireWildcard(require_react());
    var _lodash = _interopRequireDefault(require_lodash());
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var _utils = require_utils();
    var _calculateUtils = require_calculateUtils();
    var _GridItem = _interopRequireDefault(require_GridItem());
    var _ReactGridLayoutPropTypes = _interopRequireDefault(require_ReactGridLayoutPropTypes());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var layoutClassName = "react-grid-layout";
    var isFirefox = false;
    try {
      isFirefox = /firefox/i.test(navigator.userAgent);
    } catch (e) {
    }
    var ReactGridLayout = function(_React$Component) {
      _inherits(ReactGridLayout2, _React$Component);
      var _super = _createSuper(ReactGridLayout2);
      function ReactGridLayout2() {
        var _this;
        _classCallCheck(this, ReactGridLayout2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          activeDrag: null,
          layout: (0, _utils.synchronizeLayoutWithChildren)(
            _this.props.layout,
            _this.props.children,
            _this.props.cols,
            (0, _utils.compactType)(_this.props),
            _this.props.allowOverlap
          ),
          mounted: false,
          oldDragItem: null,
          oldLayout: null,
          oldResizeItem: null,
          droppingDOMNode: null,
          children: []
        });
        _defineProperty(_assertThisInitialized(_this), "dragEnterCounter", 0);
        _defineProperty(_assertThisInitialized(_this), "onDragStart", function(i, x, y, _ref) {
          var e = _ref.e, node = _ref.node;
          var layout = _this.state.layout;
          var l = (0, _utils.getLayoutItem)(layout, i);
          if (!l)
            return;
          _this.setState({
            oldDragItem: (0, _utils.cloneLayoutItem)(l),
            oldLayout: layout
          });
          return _this.props.onDragStart(layout, l, l, null, e, node);
        });
        _defineProperty(_assertThisInitialized(_this), "onDrag", function(i, x, y, _ref2) {
          var e = _ref2.e, node = _ref2.node;
          var oldDragItem = _this.state.oldDragItem;
          var layout = _this.state.layout;
          var _this$props = _this.props, cols = _this$props.cols, allowOverlap = _this$props.allowOverlap, preventCollision = _this$props.preventCollision;
          var l = (0, _utils.getLayoutItem)(layout, i);
          if (!l)
            return;
          var placeholder = {
            w: l.w,
            h: l.h,
            x: l.x,
            y: l.y,
            placeholder: true,
            i
          };
          var isUserAction = true;
          layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(_this.props), cols, allowOverlap);
          _this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);
          _this.setState({
            layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(_this.props), cols),
            activeDrag: placeholder
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onDragStop", function(i, x, y, _ref3) {
          var e = _ref3.e, node = _ref3.node;
          if (!_this.state.activeDrag)
            return;
          var oldDragItem = _this.state.oldDragItem;
          var layout = _this.state.layout;
          var _this$props2 = _this.props, cols = _this$props2.cols, preventCollision = _this$props2.preventCollision, allowOverlap = _this$props2.allowOverlap;
          var l = (0, _utils.getLayoutItem)(layout, i);
          if (!l)
            return;
          var isUserAction = true;
          layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(_this.props), cols, allowOverlap);
          _this.props.onDragStop(layout, oldDragItem, l, null, e, node);
          var newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(_this.props), cols);
          var oldLayout = _this.state.oldLayout;
          _this.setState({
            activeDrag: null,
            layout: newLayout,
            oldDragItem: null,
            oldLayout: null
          });
          _this.onLayoutMaybeChanged(newLayout, oldLayout);
        });
        _defineProperty(_assertThisInitialized(_this), "onResizeStart", function(i, w, h, _ref4) {
          var e = _ref4.e, node = _ref4.node;
          var layout = _this.state.layout;
          var l = (0, _utils.getLayoutItem)(layout, i);
          if (!l)
            return;
          _this.setState({
            oldResizeItem: (0, _utils.cloneLayoutItem)(l),
            oldLayout: _this.state.layout
          });
          _this.props.onResizeStart(layout, l, l, null, e, node);
        });
        _defineProperty(_assertThisInitialized(_this), "onResize", function(i, w, h, _ref5) {
          var e = _ref5.e, node = _ref5.node;
          var _this$state = _this.state, layout = _this$state.layout, oldResizeItem = _this$state.oldResizeItem;
          var _this$props3 = _this.props, cols = _this$props3.cols, preventCollision = _this$props3.preventCollision, allowOverlap = _this$props3.allowOverlap;
          var _withLayoutItem = (0, _utils.withLayoutItem)(layout, i, function(l2) {
            var hasCollisions;
            if (preventCollision && !allowOverlap) {
              var collisions = (0, _utils.getAllCollisions)(layout, _objectSpread(_objectSpread({}, l2), {}, {
                w,
                h
              })).filter(function(layoutItem) {
                return layoutItem.i !== l2.i;
              });
              hasCollisions = collisions.length > 0;
              if (hasCollisions) {
                var leastX = Infinity, leastY = Infinity;
                collisions.forEach(function(layoutItem) {
                  if (layoutItem.x > l2.x)
                    leastX = Math.min(leastX, layoutItem.x);
                  if (layoutItem.y > l2.y)
                    leastY = Math.min(leastY, layoutItem.y);
                });
                if (Number.isFinite(leastX))
                  l2.w = leastX - l2.x;
                if (Number.isFinite(leastY))
                  l2.h = leastY - l2.y;
              }
            }
            if (!hasCollisions) {
              l2.w = w;
              l2.h = h;
            }
            return l2;
          }), _withLayoutItem2 = _slicedToArray(_withLayoutItem, 2), newLayout = _withLayoutItem2[0], l = _withLayoutItem2[1];
          if (!l)
            return;
          var placeholder = {
            w: l.w,
            h: l.h,
            x: l.x,
            y: l.y,
            static: true,
            i
          };
          _this.props.onResize(newLayout, oldResizeItem, l, placeholder, e, node);
          _this.setState({
            layout: allowOverlap ? newLayout : (0, _utils.compact)(newLayout, (0, _utils.compactType)(_this.props), cols),
            activeDrag: placeholder
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onResizeStop", function(i, w, h, _ref6) {
          var e = _ref6.e, node = _ref6.node;
          var _this$state2 = _this.state, layout = _this$state2.layout, oldResizeItem = _this$state2.oldResizeItem;
          var _this$props4 = _this.props, cols = _this$props4.cols, allowOverlap = _this$props4.allowOverlap;
          var l = (0, _utils.getLayoutItem)(layout, i);
          _this.props.onResizeStop(layout, oldResizeItem, l, null, e, node);
          var newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(_this.props), cols);
          var oldLayout = _this.state.oldLayout;
          _this.setState({
            activeDrag: null,
            layout: newLayout,
            oldResizeItem: null,
            oldLayout: null
          });
          _this.onLayoutMaybeChanged(newLayout, oldLayout);
        });
        _defineProperty(_assertThisInitialized(_this), "onDragOver", function(e) {
          var _e$nativeEvent$target;
          e.preventDefault();
          e.stopPropagation();
          if (isFirefox && !((_e$nativeEvent$target = e.nativeEvent.target) !== null && _e$nativeEvent$target !== void 0 && _e$nativeEvent$target.classList.contains(layoutClassName))) {
            return false;
          }
          var _this$props5 = _this.props, droppingItem = _this$props5.droppingItem, onDropDragOver = _this$props5.onDropDragOver, margin = _this$props5.margin, cols = _this$props5.cols, rowHeight = _this$props5.rowHeight, maxRows = _this$props5.maxRows, width = _this$props5.width, containerPadding = _this$props5.containerPadding, transformScale = _this$props5.transformScale;
          var onDragOverResult = onDropDragOver === null || onDropDragOver === void 0 ? void 0 : onDropDragOver(e);
          if (onDragOverResult === false) {
            if (_this.state.droppingDOMNode) {
              _this.removeDroppingPlaceholder();
            }
            return false;
          }
          var finalDroppingItem = _objectSpread(_objectSpread({}, droppingItem), onDragOverResult);
          var layout = _this.state.layout;
          var _e$nativeEvent = e.nativeEvent, layerX = _e$nativeEvent.layerX, layerY = _e$nativeEvent.layerY;
          var droppingPosition = {
            left: layerX / transformScale,
            top: layerY / transformScale,
            e
          };
          if (!_this.state.droppingDOMNode) {
            var positionParams = {
              cols,
              margin,
              maxRows,
              rowHeight,
              containerWidth: width,
              containerPadding: containerPadding || margin
            };
            var calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);
            _this.setState({
              droppingDOMNode: React.createElement("div", {
                key: finalDroppingItem.i
              }),
              droppingPosition,
              layout: [].concat(_toConsumableArray(layout), [_objectSpread(_objectSpread({}, finalDroppingItem), {}, {
                x: calculatedPosition.x,
                y: calculatedPosition.y,
                static: false,
                isDraggable: true
              })])
            });
          } else if (_this.state.droppingPosition) {
            var _this$state$droppingP = _this.state.droppingPosition, left = _this$state$droppingP.left, top = _this$state$droppingP.top;
            var shouldUpdatePosition = left != layerX || top != layerY;
            if (shouldUpdatePosition) {
              _this.setState({
                droppingPosition
              });
            }
          }
        });
        _defineProperty(_assertThisInitialized(_this), "removeDroppingPlaceholder", function() {
          var _this$props6 = _this.props, droppingItem = _this$props6.droppingItem, cols = _this$props6.cols;
          var layout = _this.state.layout;
          var newLayout = (0, _utils.compact)(layout.filter(function(l) {
            return l.i !== droppingItem.i;
          }), (0, _utils.compactType)(_this.props), cols);
          _this.setState({
            layout: newLayout,
            droppingDOMNode: null,
            activeDrag: null,
            droppingPosition: void 0
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onDragLeave", function(e) {
          e.preventDefault();
          e.stopPropagation();
          _this.dragEnterCounter--;
          if (_this.dragEnterCounter === 0) {
            _this.removeDroppingPlaceholder();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onDragEnter", function(e) {
          e.preventDefault();
          e.stopPropagation();
          _this.dragEnterCounter++;
        });
        _defineProperty(_assertThisInitialized(_this), "onDrop", function(e) {
          e.preventDefault();
          e.stopPropagation();
          var droppingItem = _this.props.droppingItem;
          var layout = _this.state.layout;
          var item = layout.find(function(l) {
            return l.i === droppingItem.i;
          });
          _this.dragEnterCounter = 0;
          _this.removeDroppingPlaceholder();
          _this.props.onDrop(layout, item, e);
        });
        return _this;
      }
      _createClass(ReactGridLayout2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.setState({
            mounted: true
          });
          this.onLayoutMaybeChanged(this.state.layout, this.props.layout);
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          return this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _lodash.default) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition;
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          if (!this.state.activeDrag) {
            var newLayout = this.state.layout;
            var oldLayout = prevState.layout;
            this.onLayoutMaybeChanged(newLayout, oldLayout);
          }
        }
      }, {
        key: "containerHeight",
        value: function containerHeight() {
          if (!this.props.autoSize)
            return;
          var nbRow = (0, _utils.bottom)(this.state.layout);
          var containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];
          return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + "px";
        }
      }, {
        key: "onLayoutMaybeChanged",
        value: function onLayoutMaybeChanged(newLayout, oldLayout) {
          if (!oldLayout)
            oldLayout = this.state.layout;
          if (!(0, _lodash.default)(oldLayout, newLayout)) {
            this.props.onLayoutChange(newLayout);
          }
        }
      }, {
        key: "placeholder",
        value: function placeholder() {
          var activeDrag = this.state.activeDrag;
          if (!activeDrag)
            return null;
          var _this$props7 = this.props, width = _this$props7.width, cols = _this$props7.cols, margin = _this$props7.margin, containerPadding = _this$props7.containerPadding, rowHeight = _this$props7.rowHeight, maxRows = _this$props7.maxRows, useCSSTransforms = _this$props7.useCSSTransforms, transformScale = _this$props7.transformScale;
          return React.createElement(_GridItem.default, {
            w: activeDrag.w,
            h: activeDrag.h,
            x: activeDrag.x,
            y: activeDrag.y,
            i: activeDrag.i,
            className: "react-grid-placeholder",
            containerWidth: width,
            cols,
            margin,
            containerPadding: containerPadding || margin,
            maxRows,
            rowHeight,
            isDraggable: false,
            isResizable: false,
            isBounded: false,
            useCSSTransforms,
            transformScale
          }, React.createElement("div", null));
        }
      }, {
        key: "processGridItem",
        value: function processGridItem(child, isDroppingItem) {
          if (!child || !child.key)
            return;
          var l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));
          if (!l)
            return null;
          var _this$props8 = this.props, width = _this$props8.width, cols = _this$props8.cols, margin = _this$props8.margin, containerPadding = _this$props8.containerPadding, rowHeight = _this$props8.rowHeight, maxRows = _this$props8.maxRows, isDraggable = _this$props8.isDraggable, isResizable = _this$props8.isResizable, isBounded = _this$props8.isBounded, useCSSTransforms = _this$props8.useCSSTransforms, transformScale = _this$props8.transformScale, draggableCancel = _this$props8.draggableCancel, draggableHandle = _this$props8.draggableHandle, resizeHandles = _this$props8.resizeHandles, resizeHandle = _this$props8.resizeHandle;
          var _this$state3 = this.state, mounted = _this$state3.mounted, droppingPosition = _this$state3.droppingPosition;
          var draggable = typeof l.isDraggable === "boolean" ? l.isDraggable : !l.static && isDraggable;
          var resizable = typeof l.isResizable === "boolean" ? l.isResizable : !l.static && isResizable;
          var resizeHandlesOptions = l.resizeHandles || resizeHandles;
          var bounded = draggable && isBounded && l.isBounded !== false;
          return React.createElement(_GridItem.default, {
            containerWidth: width,
            cols,
            margin,
            containerPadding: containerPadding || margin,
            maxRows,
            rowHeight,
            cancel: draggableCancel,
            handle: draggableHandle,
            onDragStop: this.onDragStop,
            onDragStart: this.onDragStart,
            onDrag: this.onDrag,
            onResizeStart: this.onResizeStart,
            onResize: this.onResize,
            onResizeStop: this.onResizeStop,
            isDraggable: draggable,
            isResizable: resizable,
            isBounded: bounded,
            useCSSTransforms: useCSSTransforms && mounted,
            usePercentages: !mounted,
            transformScale,
            w: l.w,
            h: l.h,
            x: l.x,
            y: l.y,
            i: l.i,
            minH: l.minH,
            minW: l.minW,
            maxH: l.maxH,
            maxW: l.maxW,
            static: l.static,
            droppingPosition: isDroppingItem ? droppingPosition : void 0,
            resizeHandles: resizeHandlesOptions,
            resizeHandle
          }, child);
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          var _this$props9 = this.props, className = _this$props9.className, style = _this$props9.style, isDroppable = _this$props9.isDroppable, innerRef = _this$props9.innerRef;
          var mergedClassName = (0, _clsx.default)(layoutClassName, className);
          var mergedStyle = _objectSpread({
            height: this.containerHeight()
          }, style);
          return React.createElement("div", {
            ref: innerRef,
            className: mergedClassName,
            style: mergedStyle,
            onDrop: isDroppable ? this.onDrop : _utils.noop,
            onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,
            onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,
            onDragOver: isDroppable ? this.onDragOver : _utils.noop
          }, React.Children.map(this.props.children, function(child) {
            return _this2.processGridItem(child);
          }), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, prevState) {
          var newLayoutBase;
          if (prevState.activeDrag) {
            return null;
          }
          if (!(0, _lodash.default)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {
            newLayoutBase = nextProps.layout;
          } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {
            newLayoutBase = prevState.layout;
          }
          if (newLayoutBase) {
            var newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);
            return {
              layout: newLayout,
              compactType: nextProps.compactType,
              children: nextProps.children,
              propsLayout: nextProps.layout
            };
          }
          return null;
        }
      }]);
      return ReactGridLayout2;
    }(React.Component);
    exports.default = ReactGridLayout;
    _defineProperty(ReactGridLayout, "displayName", "ReactGridLayout");
    _defineProperty(ReactGridLayout, "propTypes", _ReactGridLayoutPropTypes.default);
    _defineProperty(ReactGridLayout, "defaultProps", {
      autoSize: true,
      cols: 12,
      className: "",
      style: {},
      draggableHandle: "",
      draggableCancel: "",
      containerPadding: null,
      rowHeight: 150,
      maxRows: Infinity,
      layout: [],
      margin: [10, 10],
      isBounded: false,
      isDraggable: true,
      isResizable: true,
      allowOverlap: false,
      isDroppable: false,
      useCSSTransforms: true,
      transformScale: 1,
      verticalCompact: true,
      compactType: "vertical",
      preventCollision: false,
      droppingItem: {
        i: "__dropping-elem__",
        h: 1,
        w: 1
      },
      resizeHandles: ["se"],
      onLayoutChange: _utils.noop,
      onDragStart: _utils.noop,
      onDrag: _utils.noop,
      onDragStop: _utils.noop,
      onResizeStart: _utils.noop,
      onResize: _utils.noop,
      onResizeStop: _utils.noop,
      onDrop: _utils.noop,
      onDropDragOver: _utils.noop
    });
  }
});

// node_modules/react-grid-layout/build/responsiveUtils.js
var require_responsiveUtils = __commonJS({
  "node_modules/react-grid-layout/build/responsiveUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;
    exports.getBreakpointFromWidth = getBreakpointFromWidth;
    exports.getColsFromBreakpoint = getColsFromBreakpoint;
    exports.sortBreakpoints = sortBreakpoints;
    var _utils = require_utils();
    function getBreakpointFromWidth(breakpoints, width) {
      var sorted = sortBreakpoints(breakpoints);
      var matching = sorted[0];
      for (var i = 1, len = sorted.length; i < len; i++) {
        var breakpointName = sorted[i];
        if (width > breakpoints[breakpointName])
          matching = breakpointName;
      }
      return matching;
    }
    function getColsFromBreakpoint(breakpoint, cols) {
      if (!cols[breakpoint]) {
        throw new Error("ResponsiveReactGridLayout: `cols` entry for breakpoint " + breakpoint + " is missing!");
      }
      return cols[breakpoint];
    }
    function findOrGenerateResponsiveLayout(layouts, breakpoints, breakpoint, lastBreakpoint, cols, compactType) {
      if (layouts[breakpoint])
        return (0, _utils.cloneLayout)(layouts[breakpoint]);
      var layout = layouts[lastBreakpoint];
      var breakpointsSorted = sortBreakpoints(breakpoints);
      var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));
      for (var i = 0, len = breakpointsAbove.length; i < len; i++) {
        var b = breakpointsAbove[i];
        if (layouts[b]) {
          layout = layouts[b];
          break;
        }
      }
      layout = (0, _utils.cloneLayout)(layout || []);
      return (0, _utils.compact)((0, _utils.correctBounds)(layout, {
        cols
      }), compactType, cols);
    }
    function sortBreakpoints(breakpoints) {
      var keys = Object.keys(breakpoints);
      return keys.sort(function(a, b) {
        return breakpoints[a] - breakpoints[b];
      });
    }
  }
});

// node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js
var require_ResponsiveReactGridLayout = __commonJS({
  "node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _lodash = _interopRequireDefault(require_lodash());
    var _utils = require_utils();
    var _responsiveUtils = require_responsiveUtils();
    var _ReactGridLayout = _interopRequireDefault(require_ReactGridLayout());
    var _excluded = ["breakpoint", "breakpoints", "cols", "layouts", "margin", "containerPadding", "onBreakpointChange", "onLayoutChange", "onWidthChange"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var type = function type2(obj) {
      return Object.prototype.toString.call(obj);
    };
    function getIndentationValue(param, breakpoint) {
      if (param == null)
        return null;
      return Array.isArray(param) ? param : param[breakpoint];
    }
    var ResponsiveReactGridLayout = function(_React$Component) {
      _inherits(ResponsiveReactGridLayout2, _React$Component);
      var _super = _createSuper(ResponsiveReactGridLayout2);
      function ResponsiveReactGridLayout2() {
        var _this;
        _classCallCheck(this, ResponsiveReactGridLayout2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", _this.generateInitialState());
        _defineProperty(_assertThisInitialized(_this), "onLayoutChange", function(layout) {
          _this.props.onLayoutChange(layout, _objectSpread(_objectSpread({}, _this.props.layouts), {}, _defineProperty({}, _this.state.breakpoint, layout)));
        });
        return _this;
      }
      _createClass(ResponsiveReactGridLayout2, [{
        key: "generateInitialState",
        value: function generateInitialState() {
          var _this$props = this.props, width = _this$props.width, breakpoints = _this$props.breakpoints, layouts = _this$props.layouts, cols = _this$props.cols;
          var breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);
          var colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);
          var compactType = this.props.verticalCompact === false ? null : this.props.compactType;
          var initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);
          return {
            layout: initialLayout,
            breakpoint,
            cols: colNo
          };
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _lodash.default)(this.props.breakpoints, prevProps.breakpoints) || !(0, _lodash.default)(this.props.cols, prevProps.cols)) {
            this.onWidthChange(prevProps);
          }
        }
      }, {
        key: "onWidthChange",
        value: function onWidthChange(prevProps) {
          var _this$props2 = this.props, breakpoints = _this$props2.breakpoints, cols = _this$props2.cols, layouts = _this$props2.layouts, compactType = _this$props2.compactType;
          var newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);
          var lastBreakpoint = this.state.breakpoint;
          var newCols = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);
          var newLayouts = _objectSpread({}, layouts);
          if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {
            if (!(lastBreakpoint in newLayouts))
              newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);
            var layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);
            layout = (0, _utils.synchronizeLayoutWithChildren)(layout, this.props.children, newCols, compactType, this.props.allowOverlap);
            newLayouts[newBreakpoint] = layout;
            this.props.onLayoutChange(layout, newLayouts);
            this.props.onBreakpointChange(newBreakpoint, newCols);
            this.setState({
              breakpoint: newBreakpoint,
              layout,
              cols: newCols
            });
          }
          var margin = getIndentationValue(this.props.margin, newBreakpoint);
          var containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);
          this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props3 = this.props, breakpoint = _this$props3.breakpoint, breakpoints = _this$props3.breakpoints, cols = _this$props3.cols, layouts = _this$props3.layouts, margin = _this$props3.margin, containerPadding = _this$props3.containerPadding, onBreakpointChange = _this$props3.onBreakpointChange, onLayoutChange = _this$props3.onLayoutChange, onWidthChange = _this$props3.onWidthChange, other = _objectWithoutProperties(_this$props3, _excluded);
          return React.createElement(_ReactGridLayout.default, _extends({}, other, {
            margin: getIndentationValue(margin, this.state.breakpoint),
            containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),
            onLayoutChange: this.onLayoutChange,
            layout: this.state.layout,
            cols: this.state.cols
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, prevState) {
          if (!(0, _lodash.default)(nextProps.layouts, prevState.layouts)) {
            var breakpoint = prevState.breakpoint, _cols = prevState.cols;
            var newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, _cols, nextProps.compactType);
            return {
              layout: newLayout,
              layouts: nextProps.layouts
            };
          }
          return null;
        }
      }]);
      return ResponsiveReactGridLayout2;
    }(React.Component);
    exports.default = ResponsiveReactGridLayout;
    _defineProperty(ResponsiveReactGridLayout, "propTypes", {
      breakpoint: _propTypes.default.string,
      breakpoints: _propTypes.default.object,
      allowOverlap: _propTypes.default.bool,
      cols: _propTypes.default.object,
      margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),
      containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),
      layouts: function layouts(props, propName) {
        if (type(props[propName]) !== "[object Object]") {
          throw new Error("Layout property must be an object. Received: " + type(props[propName]));
        }
        Object.keys(props[propName]).forEach(function(key) {
          if (!(key in props.breakpoints)) {
            throw new Error("Each key in layouts must align with a key in breakpoints.");
          }
          (0, _utils.validateLayout)(props.layouts[key], "layouts." + key);
        });
      },
      width: _propTypes.default.number.isRequired,
      onBreakpointChange: _propTypes.default.func,
      onLayoutChange: _propTypes.default.func,
      onWidthChange: _propTypes.default.func
    });
    _defineProperty(ResponsiveReactGridLayout, "defaultProps", {
      breakpoints: {
        lg: 1200,
        md: 996,
        sm: 768,
        xs: 480,
        xxs: 0
      },
      cols: {
        lg: 12,
        md: 10,
        sm: 6,
        xs: 4,
        xxs: 2
      },
      containerPadding: {
        lg: null,
        md: null,
        sm: null,
        xs: null,
        xxs: null
      },
      layouts: {},
      margin: [10, 10],
      allowOverlap: false,
      onBreakpointChange: _utils.noop,
      onLayoutChange: _utils.noop,
      onWidthChange: _utils.noop
    });
  }
});

// node_modules/react-grid-layout/build/components/WidthProvider.js
var require_WidthProvider = __commonJS({
  "node_modules/react-grid-layout/build/components/WidthProvider.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = WidthProvideRGL;
    var React = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var _excluded = ["measureBeforeMount"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var layoutClassName = "react-grid-layout";
    function WidthProvideRGL(ComposedComponent) {
      var _class;
      return _class = function(_React$Component) {
        _inherits(WidthProvider, _React$Component);
        var _super = _createSuper(WidthProvider);
        function WidthProvider() {
          var _this;
          _classCallCheck(this, WidthProvider);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "state", {
            width: 1280
          });
          _defineProperty(_assertThisInitialized(_this), "elementRef", React.createRef());
          _defineProperty(_assertThisInitialized(_this), "mounted", false);
          _defineProperty(_assertThisInitialized(_this), "onWindowResize", function() {
            if (!_this.mounted)
              return;
            var node = _this.elementRef.current;
            if (node instanceof HTMLElement && node.offsetWidth) {
              _this.setState({
                width: node.offsetWidth
              });
            }
          });
          return _this;
        }
        _createClass(WidthProvider, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            this.mounted = true;
            window.addEventListener("resize", this.onWindowResize);
            this.onWindowResize();
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.mounted = false;
            window.removeEventListener("resize", this.onWindowResize);
          }
        }, {
          key: "render",
          value: function render() {
            var _this$props = this.props, measureBeforeMount = _this$props.measureBeforeMount, rest = _objectWithoutProperties(_this$props, _excluded);
            if (measureBeforeMount && !this.mounted) {
              return React.createElement("div", {
                className: (0, _clsx.default)(this.props.className, layoutClassName),
                style: this.props.style,
                ref: this.elementRef
              });
            }
            return React.createElement(ComposedComponent, _extends({
              innerRef: this.elementRef
            }, rest, this.state));
          }
        }]);
        return WidthProvider;
      }(React.Component), _defineProperty(_class, "defaultProps", {
        measureBeforeMount: false
      }), _defineProperty(_class, "propTypes", {
        measureBeforeMount: _propTypes.default.bool
      }), _class;
    }
  }
});

// node_modules/react-grid-layout/index.js
var require_react_grid_layout = __commonJS({
  "node_modules/react-grid-layout/index.js"(exports, module) {
    module.exports = require_ReactGridLayout().default;
    module.exports.utils = require_utils();
    module.exports.Responsive = require_ResponsiveReactGridLayout().default;
    module.exports.Responsive.utils = require_responsiveUtils();
    module.exports.WidthProvider = require_WidthProvider().default;
  }
});
export default require_react_grid_layout();
//# sourceMappingURL=react-grid-layout.js.map
